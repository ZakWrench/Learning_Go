Web App basics:
-A handler is like a controller, responsible for executing your application logic and for writing HTTP response headers and bodies.
-A router(servermux) stores mapping between the URL patterns for your application and the corresponding handlers. We usually have one sermux for your application containing all your routes.
-A web server. We can establish a web server and listen for incoming requests as part of the application itself. No need for external 3rd party server like Nginx or Apache.

Note 1: The home handler function is just a regular Go function with two parameters. The `http.ResponseWriter` parameter provides methods for assembling a HTTP response and sending it to the user, and the `*http.Request` parameter is a pointer to a struct which holds infos about the current request(like the HTTP method and the URL being requested)

Important 1: Go's servemux treats the URL pattern "/" like a catch-all.

The TCP network address that you pass to http.ListenAndServe() should be in the format "host:port".
In other Go projects/docs we might sometimes see network addresses written using named ports like ":http" or ":http-alt" instead of a number, Go attempt to look up the relevant port number from our /etc/services file when starting the server, or will return an error if a match can't be found.

To use Go projects in developement phase we can use the following commands:
go run .    go run main.go  go run snippetbox.zak.net
it creates an executable binary in your /tmp dir, then runs this binary in one step

Fixed path and subtree patterns:
Go's servemux supports two different types of URL patterns: Fixed paths, and subtree paths.
Fixed paths don't end with a trailing slash, whereas subtree paths do end with a trailing slash.
"/snippet/view" and "/snippet/create" are fixed paths. in Go's servemux, fixed paths patterns like these are only matched(and the corresponding handler called) when the request URL path exactly matches the fixed path.
"/" is an example of a subtree path(because it ends in a trailing slash). Another example would be something like "/static/". Subtree path patterns are matched(and the corresponding handler called) whenever the start of a request URL path matches the subtree path. We can think of subtree paths as acting a bit like they have a wildcard at the end. like "/**" or "/static/**"
This explains why "/" pattern is acting like a catch-all. it means match a single slash, followed by anything or nothing.

Restricting the root url pattern:
We can include a simple check in the `home` handler which ultimately has the same effect:

DefaultServeMux:
http.HandleFunc("/", home) -> do not use because DefaultServeMux is a global variable, any package can access it and register a route.
use x := http.DefaultServeMux(), then mux.HandleFunc("/home", home)

Servemux features and quirks:
-Go's servemux, longer URL patterns always take precedence over shorter ones. So if a servemux contains multiple patterns which match a request, it will always dispatch the request to the handler corresponding to the longest pattern.
It has the nice side-effect that you can register patterns in any order and it won't change how the servemux behaves.

-Request URL paths are automatically sanitized. If the request path contains any . or .. elements or repeated slashes, the user will automatically be redirected to an equivalent clean URL. For example, if a user makes a request to /foo/bar/..//baz they will automatically be sent a `301 Permanent Redirect` to `/foo/baz` instead.

-If a subtree path has been registered and a request is received for that subtree path without a trailing slash, then the user will automatically be sent `301 Permanent Redirect` to the subtree path with the slash added. For example: if you have registered the subtree path `/foo/`, then any request to `/foo` will be redirected to `/foo/`.

Host name matching:
We can include host names in our URL patterns. Which can be useful when we want to redirect all HTTP requests to a canonical URL, or if our application is acting as the back end for multiple sites or services
for example: """
mux := http.NewServeMux()
mux.HandleFunc("foo.example.org/", fooHandler)
mux.HandleFunc("bar.example.org/", barHandler)
mux.HandleFunc("/baz", bazHandler)
when it comes to pattern matching, any host-specific patterns will be checked first and if there is a match the request will be dispatched to the corresponding handler.
Only when the isn't a host-specific match found will the non-host specific patterns also be checked.

RESTful routing:
Go's servermux doesn't support routing based on the request method, it doesn't support clean URLs with variables in them, and it doesn't support regexp-based patterns.
We'll for 3rd party routers instead of Go's servemux.

Customizing HTTP headers:
+--------+----------------+--------------+---------------------------+
| Method | Pattern        | Handler      | Action                    |
+--------+----------------+--------------+---------------------------+
| ANY    | /              | home         | Display the home page     |
| ANY    | /snippet/view  | snippetView  | Display a specific snippet|
| POST   | /snippet/create| snippetCreate| Create a new snippet      |
+--------+----------------+--------------+---------------------------+

after changing the create function to only accept POST requests, some nuances must be considered:
- It's only possible to call w.WriteHeader() once per response, and after the status code has been written it can't be changed. If you try to call w.WriteHeader() a second time Go will log a warning message.
- If you don't call w.WriteHeader() explicitly, then the first call to w.Write() will automatically send a 200 OK status code to the user. So, if you want to send a non-200 status code, you must call  w.WriteHeader() before any call to w.Write().

Customizing headers:
We can include an `Allow` header with the "405 Method Not Allowed" response to let the user know which request methods are supported for that particular URL.
We can do this by using the w.Header().Set() method to add a new header to the response header map.
- Important 2: Changing the response header map after a call to w.WriteHeader() or w.Write() will no effect on the headers that the user receives. You need to make sure that your response header map contains all the headers you want before you call these methods.

Additional Infos:
System-generated headers and content sniffing:
When sending a response, Go will automatically set 3 system-generated headers:`Date`, `Content-Length`, and `Content-Type`.
Go will attempt to set the correct `Content-Type` by content sniffing the response body with the http.DetectContentType() function. if this function can't guess the content type, Go wil fall back to setting the header `Content-Type: application/octet-stream` instead.
The `http.DetectContentType()` can be confusing when since GO can't distinguish JSON from plain text, by default, JSON responses will be sent with a `Content-Type: text/plain; charset = utf-8` header. We can prevent this from happening by setting the correct header manually:
`w.Header().Set("Content-Type", "application/json")`
`w.Write([]byte('{"name":"Zak"}'))`

Manipulating the header map:
We used w.Header().Set() to add a new header to the response header map. There's also Add(), Del(), Get(), and Values() methods that we can use to read and manipulate header map too:
"""
// Set a new cache-control header. If an existing "Cache-Control" header exists
// it will be overwritten.
w.Header().Set("Cache-Control", "public, max-age=31536000")
// In contrast, the Add() method appends a new "Cache-Control" header and can
// be called multiple times.
w.Header().Add("Cache-Control", "public")
w.Header().Add("Cache-Control", "max-age=31536000")
// Delete all values for the "Cache-Control" header.
w.Header().Del("Cache-Control")
// Retrieve the first value for the "Cache-Control" header.
w.Header().Get("Cache-Control")
// Retrieve a slice of all values for the "Cache-Control" header.
w.Header().Values("Cache-Control")
"""

Head Canonicalization:
when using the above methods on header map, the header name will always be canonicalized using the `textproto.CanonicalMIMEHeaderKey()` function. This convert the first letter and anyletter following a hyphen to Upper Case, and the rest of the letters to lowercase, Which has the practical implication that when calling these methods the header name is case-insensitive.
When needing to avoid canonicalization behaviour we can edit the underlying header map directly(it has the type map[string][]string):
`w.Header()["X-XSS-Protection"] = []string["1: mode=block"]`

Note 2: if a HTTP/2 connection is being used, Go will always automatically convert the header names and values to lowercase for you as per the HTTP/2 specifications.

Supressing system-generated headers:
The `Del()` method doesn't remove system-generated headers. To suppress these, we need to access the underlying header map directly and set the value to `nil`. If we want to suppress the `Date` header, for example, we write:
w.Header()["Date"] = nil

-URL query strings:
+--------+----------------------+--------------+-------------------------------+
| Method | Pattern              | Handler      | Action                        |
+--------+----------------------+--------------+-------------------------------+
| ANY    | /                    | home         | Display the home page         |
| ANY    | /snippet/view?id=1   | snippetView  | Display a specific snippet    |
| POST   | /snippet/create      | snippetCreate| Create a new snippet          |
+--------+----------------------+--------------+-------------------------------+

We use the id parameter to select a specific snippet from a database and show it to the user.
For now we'll just read the value of the id parameter and interpolate it with a placeholder response.
We update the snippetView handler function to do 2 things:
1-It needs to retrieve the value of the `id` parameter from the URL query string, which we can do using the r.URL.Query().Get() method. This will always return a string value for a parameter, or the empty string "" if no matching parameter exists.
2-Because the id parameter is untrusted user input, we should validate it to make sure it's sane and sensible. We want to check that it contains a positive integer value. We try to convert the string value to an integer with `strconv.Atoi()`, then checking the value is greater than zero.

The io.writer interface:
