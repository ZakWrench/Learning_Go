Web App basics:
-A handler is like a controller, responsible for executing your application logic and for writing HTTP response headers and bodies.
-A router(servermux) stores mapping between the URL patterns for your application and the corresponding handlers. We usually have one sermux for your application containing all your routes.
-A web server. We can establish a web server and listen for incoming requests as part of the application itself. No need for external 3rd party server like Nginx or Apache.

Note 1: The home handler function is just a regular Go function with two parameters. The `http.ResponseWriter` parameter provides methods for assembling a HTTP response and sending it to the user, and the `*http.Request` parameter is a pointer to a struct which holds infos about the current request(like the HTTP method and the URL being requested)

Important 1: Go's servemux treats the URL pattern "/" like a catch-all.

The TCP network address that you pass to http.ListenAndServe() should be in the format "host:port".
In other Go projects/docs we might sometimes see network addresses written using named ports like ":http" or ":http-alt" instead of a number, Go attempt to look up the relevant port number from our /etc/services file when starting the server, or will return an error if a match can't be found.

To use Go projects in developement phase we can use the following commands:
go run .    go run main.go  go run snippetbox.zak.net
it creates an executable binary in your /tmp dir, then runs this binary in one step

Fixed path and subtree patterns:
Go's servemux supports two different types of URL patterns: Fixed paths, and subtree paths.
Fixed paths don't end with a trailing slash, whereas subtree paths do end with a trailing slash.
"/snippet/view" and "/snippet/create" are fixed paths. in Go's servemux, fixed paths patterns like these are only matched(and the corresponding handler called) when the request URL path exactly matches the fixed path.
"/" is an example of a subtree path(because it ends in a trailing slash). Another example would be something like "/static/". Subtree path patterns are matched(and the corresponding handler called) whenever the start of a request URL path matches the subtree path. We can think of subtree paths as acting a bit like they have a wildcard at the end. like "/**" or "/static/**"
This explains why "/" pattern is acting like a catch-all. it means match a single slash, followed by anything or nothing.

Restricting the root url pattern:
We can include a simple check in the `home` handler which ultimately has the same effect:

DefaultServeMux:
http.HandleFunc("/", home) -> do not use because DefaultServeMux is a global variable, any package can access it and register a route.
use x := http.DefaultServeMux(), then mux.HandleFunc("/home", home)

Servemux features and quirks:
-Go's servemux, longer URL patterns always take precedence over shorter ones. So if a servemux contains multiple patterns which match a request, it will always dispatch the request to the handler corresponding to the longest pattern.
It has the nice side-effect that you can register patterns in any order and it won't change how the servemux behaves.

-Request URL paths are automatically sanitized. If the request path contains any . or .. elements or repeated slashes, the user will automatically be redirected to an equivalent clean URL. For example, if a user makes a request to /foo/bar/..//baz they will automatically be sent a `301 Permanent Redirect` to `/foo/baz` instead.

-If a subtree path has been registered and a request is received for that subtree path without a trailing slash, then the user will automatically be sent `301 Permanent Redirect` to the subtree path with the slash added. For example: if you have registered the subtree path `/foo/`, then any request to `/foo` will be redirected to `/foo/`.

Host name matching:
We can include host names in our URL patterns. Which can be useful when we want to redirect all HTTP requests to a canonical URL, or if our application is acting as the back end for multiple sites or services
for example: """
mux := http.NewServeMux()
mux.HandleFunc("foo.example.org/", fooHandler)
mux.HandleFunc("bar.example.org/", barHandler)
mux.HandleFunc("/baz", bazHandler)
when it comes to pattern matching, any host-specific patterns will be checked first and if there is a match the request will be dispatched to the corresponding handler.
Only when the isn't a host-specific match found will the non-host specific patterns also be checked.

RESTful routing:
Go's servermux doesn't support routing based on the request method, it doesn't support clean URLs with variables in them, and it doesn't support regexp-based patterns.
We'll for 3rd party routers instead of Go's servemux.

Customizing HTTP headers:
+--------+----------------+--------------+---------------------------+
| Method | Pattern        | Handler      | Action                    |
+--------+----------------+--------------+---------------------------+
| ANY    | /              | home         | Display the home page     |
| ANY    | /snippet/view  | snippetView  | Display a specific snippet|
| POST   | /snippet/create| snippetCreate| Create a new snippet      |
+--------+----------------+--------------+---------------------------+

after changing the create function to only accept POST requests, some nuances must be considered:
- It's only possible to call w.WriteHeader() once per response, and after the status code has been written it can't be changed. If you try to call w.WriteHeader() a second time Go will log a warning message.
- If you don't call w.WriteHeader() explicitly, then the first call to w.Write() will automatically send a 200 OK status code to the user. So, if you want to send a non-200 status code, you must call  w.WriteHeader() before any call to w.Write().

Customizing headers:
We can include an `Allow` header with the "405 Method Not Allowed" response to let the user know which request methods are supported for that particular URL.
We can do this by using the w.Header().Set() method to add a new header to the response header map.
- Important 2: Changing the response header map after a call to w.WriteHeader() or w.Write() will no effect on the headers that the user receives. You need to make sure that your response header map contains all the headers you want before you call these methods.

Additional Infos:
System-generated headers and content sniffing:
When sending a response, Go will automatically set 3 system-generated headers:`Date`, `Content-Length`, and `Content-Type`.
Go will attempt to set the correct `Content-Type` by content sniffing the response body with the http.DetectContentType() function. if this function can't guess the content type, Go wil fall back to setting the header `Content-Type: application/octet-stream` instead.
The `http.DetectContentType()` can be confusing when since GO can't distinguish JSON from plain text, by default, JSON responses will be sent with a `Content-Type: text/plain; charset = utf-8` header. We can prevent this from happening by setting the correct header manually:
`w.Header().Set("Content-Type", "application/json")`
`w.Write([]byte('{"name":"Zak"}'))`

Manipulating the header map:
We used w.Header().Set() to add a new header to the response header map. There's also Add(), Del(), Get(), and Values() methods that we can use to read and manipulate header map too:
"""
// Set a new cache-control header. If an existing "Cache-Control" header exists
// it will be overwritten.
w.Header().Set("Cache-Control", "public, max-age=31536000")
// In contrast, the Add() method appends a new "Cache-Control" header and can
// be called multiple times.
w.Header().Add("Cache-Control", "public")
w.Header().Add("Cache-Control", "max-age=31536000")
// Delete all values for the "Cache-Control" header.
w.Header().Del("Cache-Control")
// Retrieve the first value for the "Cache-Control" header.
w.Header().Get("Cache-Control")
// Retrieve a slice of all values for the "Cache-Control" header.
w.Header().Values("Cache-Control")
"""

Head Canonicalization:
when using the above methods on header map, the header name will always be canonicalized using the `textproto.CanonicalMIMEHeaderKey()` function. This convert the first letter and anyletter following a hyphen to Upper Case, and the rest of the letters to lowercase, Which has the practical implication that when calling these methods the header name is case-insensitive.
When needing to avoid canonicalization behaviour we can edit the underlying header map directly(it has the type map[string][]string):
`w.Header()["X-XSS-Protection"] = []string["1: mode=block"]`

Note 2: if a HTTP/2 connection is being used, Go will always automatically convert the header names and values to lowercase for you as per the HTTP/2 specifications.

Supressing system-generated headers:
The `Del()` method doesn't remove system-generated headers. To suppress these, we need to access the underlying header map directly and set the value to `nil`. If we want to suppress the `Date` header, for example, we write:
w.Header()["Date"] = nil

-URL query strings:
+--------+----------------------+--------------+-------------------------------+
| Method | Pattern              | Handler      | Action                        |
+--------+----------------------+--------------+-------------------------------+
| ANY    | /                    | home         | Display the home page         |
| ANY    | /snippet/view?id=1   | snippetView  | Display a specific snippet    |
| POST   | /snippet/create      | snippetCreate| Create a new snippet          |
+--------+----------------------+--------------+-------------------------------+

We use the id parameter to select a specific snippet from a database and show it to the user.
For now we'll just read the value of the id parameter and interpolate it with a placeholder response.
We update the snippetView handler function to do 2 things:
1-It needs to retrieve the value of the `id` parameter from the URL query string, which we can do using the r.URL.Query().Get() method. This will always return a string value for a parameter, or the empty string "" if no matching parameter exists.
2-Because the id parameter is untrusted user input, we should validate it to make sure it's sane and sensible. We want to check that it contains a positive integer value. We try to convert the string value to an integer with `strconv.Atoi()`, then checking the value is greater than zero.

The io.writer interface:
fmt.Fprintf(w io.Writer, format string, a ...any)(n int, err error)
But we passed it our http.ResponseWriter object instead, and worked fine.
We can do this because the io.Writer type is an nterface, and http.ResponseWriter object "satisfies the interface" because it has a w.Write() method.
Overall, anywhere you see io.Writer parameter it's OK to pass in your http.ResponseWriter object, whatever is being written will subsequently be sent as the body of the HTTP response.

-Project Structure and Organization:
->Don't over-complicate things. Only try hard to add structure and complexity owhen it's demonstrably needed.

-The `cmd` dir wil contain the `application-specific` code for the executable applications in the project. for now we'll have just one executable application "The Web Application" which will live under the cmd/web dir.
-The `internal` dir will contain the ancillary `non-application-specific` code used in the project. We'll use it to hold potentially reusable code like validation helpers and the SQL database models for the project.
-The `ui` dir will contain the `user-interface assets` used by the web application. Specifically, the `ui/html` dir will contain HTML templates, and the `ui/static` dir will contain static files(like CSS and images)
This has 2 advantages:
1- It gives a clean separation between Go and non-Go assets. All the Go code we write will live exclusively under the `cmd` and `internal` dir, leaving the project root free to hold non-Go assets like UI files, makefiles and module definitions(including our go.mod). This can make things easier to manage when it comes to building and deploying our application in the future.
2- It scales really nicely if you want to add another executable application to your project. For example, we might want to add a CLI to automate some administrative tasks in the future. With this structure, we could create this CLI app under `cmd/cli` and it will be able to import and reuse all the code you've written under the `internal` dir.

Additional information: Theinternal directory
It's important to point out that the firectory nae `internal` carries a special meaning and behavior in Go: any packages which live under this directory can only be imported by code |inside theparent of the `internal` directory|. In our case, thismeans thatany packages which live in `internal` can only beimported by codeinside our `snippetbox` project dir.
Or, looking at it the other way, this means that any packages under `internal` |cannot be imported by code outside of your project|
This is useful beause it prevents other codebases from importing and relying on the packages in our `internal` dir, even if the project code is publicly available somewhere like GitHub.

- HTML Templating and Inheritance:
We start creating a template file at `ui/html/pages/home.tmpl` which contain HTML content for our home page.
Note 3: the `.tmpl` extension doesn't convey any special meaning or behavior here. I've only chosen this extension because it's a nice way of making it clear that the file contains a Go template when you're browsing a list of files. We can always use .html extension, or use a 'double extension' like `.tmpl.html`.
Next we need to use Go's `html/template` package, which provides a family of functions for safely parsing and rendering HTML templates. We can use the funcions in the package to parse the template file and then execute the template.

Template composition:
As we add more pages to this web application there will be some shared, boulerplate, HTML markup that we want to include on every page, like the header, navigation, and metadata inside the <head> HTML element.
So it's a good idea to create a base(or master) template which contains this shared content, which we can then compose with the page-specific markup for the individual pages. We'll create a new ui/html/base.tmpl file

We use the {{define "base"}}...{{end}} action to define a distinct named template called `base`, which contain the content we want to appear on every page.
Here we're use the {{template "title" .}} and {{template "main" .}} actions to denote that we want to inove other named templates(caled `title` and `main`) at a particular point in the HTML.
Note 4: the dot at the end of the {{template "title" .}} action represent any dynamic data that you want to pass to the invoked template.

So now, instead of containing HTML directly, our template set contains 3 named templates, base, title, and main. We use `ExecuteTemplate()` method to tell Go that we specifically want to respond using the content of the `base` template(which in turn invokes our `title` and `main` template)

Embedding partials:
We might want to break out certain bits of HTML into partials that can be reused in different pages or layouts.

Additional informations:
-The block action:
We used {{template}} action to invoke onetemplate from another.
But Go also provides a {{block}} ... {{end}} action which you can use instead. This acts like the {{template}} action, except it allows you to speciy some default content if the template being invoked `doesn't exist in the current template set`.
In the context of a web application, this is useful when you want to provide some default content(such as sidebar) which individual pages can override on a case-by-case basis if they need to.
Syntactically you use it like this:
{{define "base"}}
    <h1>An example template</h1>
    {{block "sidebar" .}}
        <p>My default sidebar content</p>
    {{end}}
{{end}}
But if you want, you don't need to include any default content between the {{block}} and {{end}} actions. In that case, the invoked template acts like it's 'optional'. If the template exist in the template set, then it will be rendered. But if it doesn't , then nothing will be displayed.
-Embedding files:
Go also provides the `embed` package which makes it possible to 'embed files into our Go program itself rather than reading them from disk'.

-SERVING STATIC FILES:
The http.Fileserver handler:
Go's `net/http` package ships with a built-in http.FileServer handler which you can use to serve files over HTTP from a specific directory. Let's add a new route to our applicatoin so that all requests which begin with "/static/" are handled using this:

| Method | Pattern                   | Handler        | Action                    |
|--------|---------------------------|----------------|---------------------------|
| ANY    | /                         | home           | Display the home page     |
| ANY    | /snippet/view?id=1        | snippetView    | Display a specific snippet|
| POST   | /snippet/create           | snippetCreate  | Create a new snippet      |
| ANY    | /static/                  | http.FileServer| Serve a specific static file |

Remember, The pattern "/static/" is a subtree path pattern, so it acts a bit like there is a wildcard at the end.
When creating http.FileServer handler, we use the `http.FileServer()` function like this:
fileServer := http.FileServer(http.Dir("./ui/static/"))
When this handler receives a request, it will remove the leading slash from the URL path and then search the `./ui/static` for the corresponding file to send to the user.
