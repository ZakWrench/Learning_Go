Web App basics:
-A handler is like a controller, responsible for executing your application logic and for writing HTTP response headers and bodies.
-A router(servermux) stores mapping between the URL patterns for your application and the corresponding handlers. We usually have one sermux for your application containing all your routes.
-A web server. We can establish a web server and listen for incoming requests as part of the application itself. No need for external 3rd party server like Nginx or Apache.

Note 1: The home handler function is just a regular Go function with two parameters. The `http.ResponseWriter` parameter provides methods for assembling a HTTP response and sending it to the user, and the `*http.Request` parameter is a pointer to a struct which holds infos about the current request(like the HTTP method and the URL being requested)

Important 1: Go's servemux treats the URL pattern "/" like a catch-all.

The TCP network address that you pass to http.ListenAndServe() should be in the format "host:port".
In other Go projects/docs we might sometimes see network addresses written using named ports like ":http" or ":http-alt" instead of a number, Go attempt to look up the relevant port number from our /etc/services file when starting the server, or will return an error if a match can't be found.

To use Go projects in developement phase we can use the following commands:
go run .    go run main.go  go run snippetbox.zak.net
it creates an executable binary in your /tmp dir, then runs this binary in one step

Fixed path and subtree patterns:
Go's servemux supports two different types of URL patterns: Fixed paths, and subtree paths.
Fixed paths don't end with a trailing slash, whereas subtree paths do end with a trailing slash.
"/snippet/view" and "/snippet/create" are fixed paths. in Go's servemux, fixed paths patterns like these are only matched(and the corresponding handler called) when the request URL path exactly matches the fixed path.
"/" is an example of a subtree path(because it ends in a trailing slash). Another example would be something like "/static/". Subtree path patterns are matched(and the corresponding handler called) whenever the start of a request URL path matches the subtree path. We can think of subtree paths as acting a bit like they have a wildcard at the end. like "/**" or "/static/**"
This explains why "/" pattern is acting like a catch-all. it means match a single slash, followed by anything or nothing.

Restricting the root url pattern:
We can include a simple check in the `home` handler which ultimately has the same effect:

DefaultServeMux:
http.HandleFunc("/", home) -> do not use because DefaultServeMux is a global variable, any package can access it and register a route.
use x := http.DefaultServeMux(), then mux.HandleFunc("/home", home)

Servemux features and quirks:
-Go's servemux, longer URL patterns always take precedence over shorter ones. So if a servemux contains multiple patterns which match a request, it will always dispatch the request to the handler corresponding to the longest pattern.
It has the nice side-effect that you can register patterns in any order and it won't change how the servemux behaves.

-Request URL paths are automatically sanitized. If the request path contains any . or .. elements or repeated slashes, the user will automatically be redirected to an equivalent clean URL. For example, if a user makes a request to /foo/bar/..//baz they will automatically be sent a `301 Permanent Redirect` to `/foo/baz` instead.

-If a subtree path has been registered and a request is received for that subtree path without a trailing slash, then the user will automatically be sent `301 Permanent Redirect` to the subtree path with the slash added. For example: if you have registered the subtree path `/foo/`, then any request to `/foo` will be redirected to `/foo/`.

