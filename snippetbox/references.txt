Web App basics:
-A handler is like a controller, responsible for executing your application logic and for writing HTTP response headers and bodies.
-A router(servermux) stores mapping between the URL patterns for your application and the corresponding handlers. We usually have one sermux for your application containing all your routes.
-A web server. We can establish a web server and listen for incoming requests as part of the application itself. No need for external 3rd party server like Nginx or Apache.

Note 1: The home handler function is just a regular Go function with two parameters. The `http.ResponseWriter` parameter provides methods for assembling a HTTP response and sending it to the user, and the `*http.Request` parameter is a pointer to a struct which holds infos about the current request(like the HTTP method and the URL being requested)

Important 1: Go's servemux treats the URL pattern "/" like a catch-all.

The TCP network address that you pass to http.ListenAndServe() should be in the format "host:port".
In other Go projects/docs we might sometimes see network addresses written using named ports like ":http" or ":http-alt" instead of a number, Go attempt to look up the relevant port number from our /etc/services file when starting the server, or will return an error if a match can't be found.

To use Go projects in developement phase we can use the following commands:
go run .    go run main.go  go run snippetbox.zak.net
it creates an executable binary in your /tmp dir, then runs this binary in one step

Fixed path and subtree patterns:
Go's servemux supports two different types of URL patterns: Fixed paths, and subtree paths.
Fixed paths don't end with a trailing slash, whereas subtree paths do end with a trailing slash.
"/snippet/view" and "/snippet/create" are fixed paths. in Go's servemux, fixed paths patterns like these are only matched(and the corresponding handler called) when the request URL path exactly matches the fixed path.
"/" is an example of a subtree path(because it ends in a trailing slash). Another example would be something like "/static/". Subtree path patterns are matched(and the corresponding handler called) whenever the start of a request URL path matches the subtree path. We can think of subtree paths as acting a bit like they have a wildcard at the end. like "/**" or "/static/**"
This explains why "/" pattern is acting like a catch-all. it means match a single slash, followed by anything or nothing.

Restricting the root url pattern:
We can include a simple check in the `home` handler which ultimately has the same effect:

DefaultServeMux:
http.HandleFunc("/", home) -> do not use because DefaultServeMux is a global variable, any package can access it and register a route.
use x := http.DefaultServeMux(), then mux.HandleFunc("/home", home)

Servemux features and quirks:
-Go's servemux, longer URL patterns always take precedence over shorter ones. So if a servemux contains multiple patterns which match a request, it will always dispatch the request to the handler corresponding to the longest pattern.
It has the nice side-effect that you can register patterns in any order and it won't change how the servemux behaves.

-Request URL paths are automatically sanitized. If the request path contains any . or .. elements or repeated slashes, the user will automatically be redirected to an equivalent clean URL. For example, if a user makes a request to /foo/bar/..//baz they will automatically be sent a `301 Permanent Redirect` to `/foo/baz` instead.

-If a subtree path has been registered and a request is received for that subtree path without a trailing slash, then the user will automatically be sent `301 Permanent Redirect` to the subtree path with the slash added. For example: if you have registered the subtree path `/foo/`, then any request to `/foo` will be redirected to `/foo/`.

Host name matching:
We can include host names in our URL patterns. Which can be useful when we want to redirect all HTTP requests to a canonical URL, or if our application is acting as the back end for multiple sites or services
for example: """
mux := http.NewServeMux()
mux.HandleFunc("foo.example.org/", fooHandler)
mux.HandleFunc("bar.example.org/", barHandler)
mux.HandleFunc("/baz", bazHandler)
when it comes to pattern matching, any host-specific patterns will be checked first and if there is a match the request will be dispatched to the corresponding handler.
Only when the isn't a host-specific match found will the non-host specific patterns also be checked.

RESTful routing:
Go's servermux doesn't support routing based on the request method, it doesn't support clean URLs with variables in them, and it doesn't support regexp-based patterns.
We'll for 3rd party routers instead of Go's servemux.

Customizing HTTP headers:
+--------+----------------+--------------+---------------------------+
| Method | Pattern        | Handler      | Action                    |
+--------+----------------+--------------+---------------------------+
| ANY    | /              | home         | Display the home page     |
| ANY    | /snippet/view  | snippetView  | Display a specific snippet|
| POST   | /snippet/create| snippetCreate| Create a new snippet      |
+--------+----------------+--------------+---------------------------+

after changing the create function to only accept POST requests, some nuances must be considered:
- It's only possible to call w.WriteHeader() once per response, and after the status code has been written it can't be changed. If you try to call w.WriteHeader() a second time Go will log a warning message.
- If you don't call w.WriteHeader() explicitly, then the first call to w.Write() will automatically send a 200 OK status code to the user. So, if you want to send a non-200 status code, you must call  w.WriteHeader() before any call to w.Write().

Customizing headers:
We can include an `Allow` header with the "405 Method Not Allowed" response to let the user know which request methods are supported for that particular URL.
We can do this by using the w.Header().Set() method to add a new header to the response header map.
- Important 2: Changing the response header map after a call to w.WriteHeader() or w.Write() will no effect on the headers that the user receives. You need to make sure that your response header map contains all the headers you want before you call these methods.

